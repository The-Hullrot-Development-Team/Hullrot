using System.Numerics;
using Content.Client.UserInterface.Systems.Chat.Widgets;
using Content.Shared.CCVar;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared;
using Robust.Shared.Configuration;

namespace Content.Client.UserInterface.Screens;

[GenerateTypedNameReferences]
public sealed partial class SeparatedChatGameScreen : InGameScreen
{
    [Dependency] private readonly IConfigurationManager _cfg = default!;
    [Dependency] private readonly IUserInterfaceManager _uiManager = default!;

    // The minimum width of InventoryGui + HotbarGui combined.
    // Used to keep the PDA from overlapping the shoes slot.
    private const int INVENTORY_MINIMUM_WIDTH =
        (125 /* width */ - 2 /* negative margin */) * 2 /* ItemStatusPanel */
        + 68 /* width */ * 10 /* ItemSlotButton, including inventory */
        + 67 /* width */ * 2 /* hands */;

    private readonly float _chatMinWidth;
    private float? _deferredSplitFraction;

    public SeparatedChatGameScreen()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        AutoscaleMaxResolution = new Vector2i(1080, 770);

        SetAnchorPreset(ScreenContainer, LayoutPreset.Wide);
        SetAnchorPreset(ViewportContainer, LayoutPreset.Wide);
        SetAnchorPreset(MainViewport, LayoutPreset.Wide);
        SetAnchorAndMarginPreset(Inventory, LayoutPreset.BottomLeft, margin: 5);
        SetAnchorAndMarginPreset(TopLeftContainer, LayoutPreset.TopLeft, margin: 10);
        SetAnchorAndMarginPreset(Ghost, LayoutPreset.BottomWide, margin: 80);
        SetAnchorAndMarginPreset(Hotbar, LayoutPreset.BottomWide, margin: 5);
        SetAnchorAndMarginPreset(Alerts, LayoutPreset.CenterRight, margin: 10);

        ScreenContainer.OnSplitResizeFinished += () =>
            OnChatResized?.Invoke(new Vector2(ScreenContainer.SplitFraction, 0));

        ViewportContainer.OnResized += ResizeActionContainer;

        OnResized += RecalculateViewportDesiredSize;
        // Note: currently these run after the like callbacks on MainViewport,
        // and may misbehave if that changes.
        _cfg.OnValueChanged(CCVars.ViewportMinimumWidth, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CCVars.ViewportStretch, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CCVars.ViewportSnapToleranceClip, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CCVars.ViewportSnapToleranceMargin, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CCVars.ViewportScaleRender, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CCVars.ViewportFixedScaleFactor, _ => RecalculateViewportDesiredSize());
        _cfg.OnValueChanged(CVars.DisplayUIScale, _ => RecalculateViewportDesiredSize());

        _chatMinWidth = SeparatedChatPanel.MinWidth;
    }

    private void ResizeActionContainer()
    {
        float indent = 20;
        Actions.ActionsContainer.MaxGridWidth = ViewportContainer.Size.X - indent;
    }

    private void RecalculateViewportDesiredSize()
    {
        // When the main window is resized, calculate a new min/max for the
        // ViewportContainer so that the chat will prefer to resize instead
        // of letterboxing the viewport.
        var uiScale = _cfg.GetCVar(CVars.DisplayUIScale);
        if (uiScale == 0f)
            uiScale = _uiManager.DefaultUIScale;

        // CurrentRenderScale would be more correct, but it gets updated after us.
        var gameScale = CalculateRenderScale();
        // svp.ViewportSize.X = EyeManager.PixelsPerMeter * gameScale * ViewportWidth
        var minFromVp = EyeManager.PixelsPerMeter * gameScale * _cfg.GetCVar(CCVars.ViewportMinimumWidth) / uiScale;
        var maxFromVp = EyeManager.PixelsPerMeter * gameScale * _cfg.GetCVar(CCVars.ViewportMaximumWidth) / uiScale;
        // Inventory bar also supplies a minWidth such that body+shoes don't overlap PDA.
        var minFromUi = INVENTORY_MINIMUM_WIDTH;
        // In case of overscaled viewport, chat hard-minWidth overpowers them both.
        var minFromChat = Width - _chatMinWidth;

        var min = Math.Min(Math.Max(minFromVp, minFromUi), minFromChat);
        var max = Math.Max(maxFromVp, min);

        // SplitContainer doesn't respect MaxSize, so set a MinSize on the chat instead.
        ViewportContainer.MinWidth = min;
        SeparatedChatPanel.MinWidth = Math.Max(_chatMinWidth, Width - max);

        if (_deferredSplitFraction is { } fraction)
        {
            ScreenContainer.SplitFraction = fraction;
            _deferredSplitFraction = null;
        }

        // Correct for naughty behavior in SplitContainer by forcing a relayout.
        ScreenContainer.SplitCenter = Math.Clamp(ScreenContainer.SplitCenter, min, max);
    }

    // Combines logic of EnsureViewportCreated and GetDrawBox to calculate the
    // effective rendering scale.
    private float CalculateRenderScale()
    {
        var svp = MainViewport.Viewport;

        if (svp.FixedStretchSize is { } fixedAmt)
        {
            return fixedAmt.X / svp.ViewportSize.X;
        }
        else
        {
            // Always act like IgnoreDimension is Horizontal - otherwise the
            // current separator position would influence the acceptable bounds
            // of the separator position, which is weird.
            return Height / svp.ViewportSize.Y;
        }
    }

    public override ChatBox ChatBox => GetWidget<ChatBox>()!;

    public override void SetChatSize(Vector2 size)
    {
        ScreenContainer.ResizeMode = SplitContainer.SplitResizeMode.RespectChildrenMinSize;

        ScreenContainer.SplitFraction = size.X;
        if (ScreenContainer.SplitFraction == 0)
        {
            // Failed because SplitContainer tried to lay out its children
            // despite being 0x0 before first draw. Queue the size for later.
            _deferredSplitFraction = size.X;
        }
    }
}
